동시성 제어 방안 비교

회의 참가자 추가 시 발생할 수 있는 정원 초과·레이스 컨디션을 방지하기 위한 네 가지 대표 패턴을 정리했습니다.

⸻

🔒 방안 1: Pessimistic Lock (권장)

이론
•	DB 레벨에서 해당 행을 SELECT … FOR UPDATE 방식으로 잠궈 다른 트랜잭션의 접근을 막습니다.
•	확실하게 동시성을 보장하지만, 잠금 대기 시간으로 성능 저하나 교착 위험이 있습니다.

코드 예시
```
// MeetingRepository.java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT m FROM Meeting m WHERE m.id = :meetingId")
Optional<Meeting> findByIdWithLock(@Param("meetingId") Long meetingId);

// MeetingDomainService.java
@Transactional
public void addParticipant(Long meetingId, Long userId) {
// 🔒 비관적 락으로 Meeting 조회
Meeting meeting = meetingRepository.findByIdWithLock(meetingId)
.orElseThrow(() -> new CustomException(MeetingError.MEETING_NOT_FOUND));

    validateForJoining(meeting, userId);

    // 🚨 락 상태에서 현재 참가자 수 재확인
    int currentCount = getCurrentParticipantCount(meetingId);
    if (currentCount >= meeting.getCapacity()) {
        throw new CustomException(MeetingError.MEETING_FULL);
    }

    Participant newParticipant = Participant.builder()
        .meetingId(meetingId)
        .userId(userId)
        .build();
    participantRepository.save(newParticipant);

    // 정원 초과 시 상태 변경
    if (currentCount + 1 >= meeting.getCapacity()) {
        meeting.changeStatus(MeetingStatus.FULL);
    }
}
```
개선 팁
•	잠금 범위를 최소화하여 트랜잭션을 짧게 유지하세요.
•	APM 도구로 잠금 대기 시간을 모니터링하세요.

⸻

🔒 방안 2: Database Unique Constraint + 트리거

이론
•	DB 스키마에 제약 조건(CHECK) 또는 트리거를 걸어 용량 초과를 차단합니다.
•	애플리케이션 레벨 로직과 무관하게 무결성을 유지하지만, 예외 처리 로직이 복잡해질 수 있습니다.

SQL 예시
```
-- CHECK 제약 조건
ALTER TABLE meeting_participants
ADD CONSTRAINT check_capacity
CHECK (
(SELECT COUNT(*) FROM meeting_participants mp2 WHERE mp2.meeting_id = meeting_id)
<= (SELECT capacity FROM meetings WHERE id = meeting_id)
);

-- 트리거 방식
DELIMITER //
CREATE TRIGGER prevent_overbook
BEFORE INSERT ON meeting_participants
FOR EACH ROW
BEGIN
DECLARE current_count INT;
DECLARE max_capacity INT;

    SELECT COUNT(*), m.capacity
    INTO current_count, max_capacity
    FROM meeting_participants mp
    JOIN meetings m ON mp.meeting_id = m.id
    WHERE mp.meeting_id = NEW.meeting_id;

    IF current_count >= max_capacity THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Meeting capacity exceeded';
    END IF;
END//
DELIMITER ;
```
개선 팁
•	트리거 대신 Stored Procedure를 사용해 관리성을 높이세요.
•	예외를 API 레이어에서 409 CONFLICT로 매핑하는 핸들러를 구현하세요.

⸻

🔒 방안 3: Redis Distributed Lock

이론
•	Redis SETNX를 이용해 애플리케이션 레벨 분산 락을 구현합니다.
•	DB 락보다 가볍고 분산 환경에 유리하지만, 락 해제 누락 시 교착 위험이 있습니다.

코드 예시
```
// MeetingLockService.java
@Component
@RequiredArgsConstructor
public class MeetingLockService {
private final RedisTemplate<String, String> redisTemplate;
private static final String LOCK_PREFIX = "meeting_join_lock:";
private static final int LOCK_TIMEOUT = 10; // seconds

    public boolean acquireLock(Long meetingId) {
        String lockKey = LOCK_PREFIX + meetingId;
        Boolean result = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, "locked", Duration.ofSeconds(LOCK_TIMEOUT));
        return Boolean.TRUE.equals(result);
    }

    public void releaseLock(Long meetingId) {
        redisTemplate.delete(LOCK_PREFIX + meetingId);
    }
}

// MeetingDomainService.java
@Transactional
public void addParticipant(Long meetingId, Long userId) {
if (!meetingLockService.acquireLock(meetingId)) {
throw new CustomException(MeetingError.MEETING_BUSY);
}
try {
Meeting meeting = meetingRepository.findById(meetingId)
.orElseThrow(() -> new CustomException(MeetingError.MEETING_NOT_FOUND));
validateForJoining(meeting, userId);
int currentCount = getCurrentParticipantCount(meetingId);
if (currentCount >= meeting.getCapacity()) {
throw new CustomException(MeetingError.MEETING_FULL);
}
// 참가자 추가 로직…
} finally {
meetingLockService.releaseLock(meetingId);
}
}
```
개선 팁
•	Redisson 같은 라이브러리로 자동 갱신·안전 해제를 사용하세요.
•	획득 실패 시 재시도(backoff) 로직을 넣어 사용자 경험을 개선하세요.

⸻

🔒 방안 4: Optimistic Lock + Retry

이론
•	@Version 필드를 통해 업데이트 시 버전 충돌이 발생하면 예외를 던지고 재시도합니다.
•	락 대기 비용이 없어 확장성에 유리하지만, 경쟁이 심할 경우 재시도 횟수가 많아질 수 있습니다.

코드 예시
```
// Meeting.java
@Entity
public class Meeting {
@Version
private Long version;
// …기존 필드들
}

// MeetingService.java
@Retryable(value = {OptimisticLockingFailureException.class}, maxAttempts = 3)
@Transactional
public void addParticipant(Long meetingId, Long userId) {
Meeting meeting = meetingRepository.findById(meetingId)
.orElseThrow(() -> new CustomException(MeetingError.MEETING_NOT_FOUND));
validateForJoining(meeting, userId);
int currentCount = getCurrentParticipantCount(meetingId);
if (currentCount >= meeting.getCapacity()) {
throw new CustomException(MeetingError.MEETING_FULL);
}
Participant newParticipant = Participant.builder()
.meetingId(meetingId)
.userId(userId)
.build();
participantRepository.save(newParticipant);
// 상태 변경 및 저장 → 버전 충돌 시 예외 발생
meeting.changeStatus(/* 상태 로직 */);
meetingRepository.save(meeting);
}
```
개선 팁
•	재시도 횟수와 백오프 정책을 조절해 불필요한 재시도를 줄이세요.
•	읽기·수정 로직을 분리해 충돌 가능성을 낮추세요.

⸻
